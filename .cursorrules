# Cursor AI Rules for This Project

## Project Context
This is an AGPL-3.0 licensed Python library template optimized for agentic and data-driven development. All code must maintain high quality standards and comprehensive documentation.

## Code Style & Quality

### Required for ALL Code
1. **Type Hints**: Every function must have complete type hints
2. **Docstrings**: Google-style docstrings for all public APIs
3. **Testing**: Write tests for all new functionality
4. **Formatting**: Use ruff for formatting (automatic with pre-commit)

### Type Hint Examples
```python
# ✅ Good
def process_data(data: list[dict[str, Any]], config: Config) -> pd.DataFrame:
    """Process data according to configuration."""
    ...

# ❌ Bad - No type hints
def process_data(data, config):
    ...
```

### Docstring Template
```python
def function_name(param1: Type1, param2: Type2) -> ReturnType:
    """Brief one-line description.

    Longer description if needed, explaining what the function does,
    why it exists, and any important details.

    Args:
        param1: Description of param1
        param2: Description of param2

    Returns:
        Description of return value

    Raises:
        ExceptionType: When this exception is raised

    Examples:
        >>> function_name(value1, value2)
        expected_result
    """
```

## File Organization

### Source Code Structure
- Place new modules in `src/your_package_name/`
- Mirror structure in `tests/` directory
- Keep functions small and focused (< 50 lines)
- One class per file for complex classes

### Import Order
1. Standard library imports
2. Third-party imports
3. Local imports

```python
# Standard library
import os
from pathlib import Path
from typing import Any

# Third-party
import pandas as pd
import pydantic

# Local
from your_package_name.core import MyClass
```

## Testing Requirements

### Test Structure
- Create test file `tests/test_module.py` for `src/your_package_name/module.py`
- Use descriptive test names: `test_function_name_does_what`
- Group related tests in classes

### Test Example
```python
import pytest
from your_package_name.module import function_to_test

class TestFunctionToTest:
    """Tests for function_to_test."""

    def test_basic_usage(self) -> None:
        """Test basic functionality."""
        result = function_to_test(input_data)
        assert result == expected_output

    def test_edge_case_empty_input(self) -> None:
        """Test handling of empty input."""
        with pytest.raises(ValueError):
            function_to_test([])

    @pytest.mark.slow
    def test_large_dataset(self) -> None:
        """Test with large dataset."""
        ...
```

## Git & Version Control

### Commit Message Format
```
<type>(<scope>): <subject>

<body>

<footer>
```

Types: feat, fix, docs, test, refactor, chore, ci

### Before Committing
1. Run `make format` - Auto-format code
2. Run `make lint` - Check code quality
3. Run `make test` - Verify tests pass
4. Update CHANGELOG.md

## Common Tasks

### Adding a New Feature
1. Create feature branch: `feature/feature-name`
2. Write code with type hints and docstrings
3. Add tests in `tests/`
4. Update documentation in `docs/`
5. Update CHANGELOG.md
6. Run quality checks: `make lint && make test`

### Adding a New Dependency
1. Add to `pyproject.toml` under appropriate section
2. Run `uv sync`
3. Update documentation if user-facing
4. Consider if it should be optional dependency

### Writing Data Processing Code
1. Put raw data in `data/raw/`
2. Create processing script in `scripts/`
3. Save processed data to `data/processed/`
4. Extract reusable functions to `src/`
5. Document in `data/README.md`

## License Compliance (CRITICAL)

### GPL-3.0 Requirements
- All new code must be GPL-3.0 compatible
- Do NOT use code from incompatible licenses
- Add license header to new files:

```python
# Copyright (C) YYYY Your Name
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
```

## AI-Specific Guidelines

### Code Generation
- Prioritize readability over cleverness
- Use explicit names over abbreviations
- Add comments for non-obvious logic
- Keep functions pure when possible
- Avoid global state

### Error Handling
- Raise specific exceptions (ValueError, TypeError, etc.)
- Include helpful error messages
- Document exceptions in docstrings
- Don't use bare `except:`

### Best Practices
- DRY: Don't Repeat Yourself
- SOLID principles
- Prefer composition over inheritance
- Use Pydantic for data validation
- Type-safe everywhere

## Common Patterns

### Configuration
```python
from pydantic import BaseModel, Field

class Config(BaseModel):
    """Application configuration."""

    api_key: str = Field(..., description="API key for service")
    timeout: int = Field(30, description="Request timeout in seconds")
    debug: bool = Field(False, description="Enable debug mode")
```

### Data Processing
```python
from pathlib import Path
import pandas as pd

def load_data(path: Path) -> pd.DataFrame:
    """Load data from CSV file.

    Args:
        path: Path to CSV file

    Returns:
        Loaded DataFrame

    Raises:
        FileNotFoundError: If file doesn't exist
        ValueError: If file is invalid
    """
    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")

    try:
        return pd.read_csv(path)
    except Exception as e:
        raise ValueError(f"Failed to load {path}: {e}") from e
```

### Async Operations
```python
import asyncio
from typing import Any

async def fetch_data(url: str) -> dict[str, Any]:
    """Fetch data from URL asynchronously.

    Args:
        url: URL to fetch from

    Returns:
        Parsed JSON response

    Raises:
        httpx.HTTPError: If request fails
    """
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        response.raise_for_status()
        return response.json()
```

## Don't Do This

### ❌ Bad Practices
```python
# No type hints
def process(data):
    return data.process()

# No docstring
def important_function(x: int) -> int:
    return x * 2

# No error handling
def load_file(path):
    return open(path).read()

# Bare except
try:
    risky_operation()
except:
    pass

# Magic numbers
if value > 86400:  # What is 86400?
    ...
```

### ✅ Good Practices
```python
# Complete type hints and docstring
def process(data: DataType) -> ProcessedType:
    """Process input data.

    Args:
        data: Input data to process

    Returns:
        Processed data
    """
    return data.process()

# Proper error handling
def load_file(path: Path) -> str:
    """Load file contents.

    Args:
        path: Path to file

    Returns:
        File contents

    Raises:
        FileNotFoundError: If file doesn't exist
    """
    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")
    return path.read_text()

# Named constants
SECONDS_PER_DAY = 86400
if value > SECONDS_PER_DAY:
    ...
```

## Performance Considerations

- Use generators for large datasets
- Profile before optimizing
- Cache expensive computations
- Use appropriate data structures
- Consider memory usage

## Documentation

- Keep README.md up-to-date
- Document public APIs thoroughly
- Add examples to docstrings
- Update CHANGELOG.md with changes
- Write guides for complex features

## Questions?

If unsure about anything:
1. Check existing code for patterns
2. Read CONTRIBUTING.md
3. Follow PEP 8 and PEP 257
4. Prioritize clarity and correctness

---

Remember: Good code is code that's easy to understand, test, and maintain. Write for the next developer (or AI agent) who will read your code!
